#!/usr/bin/env node

// Local-only CLI that queries the Ollama server and prints exactly one zsh command.
// Flags:
//   --model=<name> (default: cmdgen)
//   --explain       (prints a one-line # comment before the command)
//   --unsafe        (permits destructive output)

const http = require('http');

function parseFlags(argv) {
  const flags = { model: 'cmdgen', explain: false, unsafe: false };
  const rest = [];
  for (const arg of argv) {
    if (arg.startsWith('--model=')) {
      flags.model = arg.slice('--model='.length);
    } else if (arg === '--explain') {
      flags.explain = true;
    } else if (arg === '--unsafe') {
      flags.unsafe = true;
    } else {
      rest.push(arg);
    }
  }
  return { flags, rest };
}

function promptFromArgsOrStdin(restArgs) {
  return new Promise((resolve) => {
    const arg = restArgs.join(' ').trim();
    if (arg) return resolve(arg);
    let buf = '';
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', (d) => (buf += d));
    process.stdin.on('end', () => resolve(buf.trim()))
    if (process.stdin.isTTY) {
      process.stderr.write('Prompt: ');
      process.stdin.resume();
    }
  });
}

function chatOnce({ host = '127.0.0.1', port = 11434, path = '/api/chat', payload }) {
  return new Promise((resolve, reject) => {
    const req = http.request(
      { host, port, path, method: 'POST', headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) } },
      (res) => {
        let out = '';
        res.setEncoding('utf8');
        res.on('data', (d) => (out += d));
        res.on('end', () => {
          try {
            const data = JSON.parse(out);
            resolve(data);
          } catch (e) {
            reject(new Error('invalid_json'));
          }
        });
      }
    );
    req.on('error', (err) => reject(err));
    req.write(payload);
    req.end();
  });
}

function firstNonEmptyLine(text) {
  return (text || '')
    .split('\n')
    .map((l) => l.trim())
    .find((l) => l.length > 0) || '';
}

function sanitizeModelOutput(line) {
  if (!line) return '';
  let s = String(line).trim();
  // Strip fenced code blocks if present
  if (s.startsWith('```')) {
    s = s.replace(/^```[a-zA-Z0-9_-]*\s*/, '');
    s = s.replace(/\s*```$/, '');
    s = firstNonEmptyLine(s);
  }
  // Remove wrapping single backticks and any stray backticks
  if (s.startsWith('`') && s.endsWith('`')) {
    s = s.slice(1, -1).trim();
  }
  s = s.replace(/`/g, '');
  // Drop common prompt prefixes
  s = s.replace(/^\s*(?:\$|â¯|>|PS>|%)\s+/, '');
  return s.trim();
}

(async () => {
  try {
    const { flags, rest } = parseFlags(process.argv.slice(2));
    const content = await promptFromArgsOrStdin(rest);
    if (!content) process.exit(1);

    const sysPrompt = undefined; // System prompt lives in the Modelfile
    const userPrompt = content + (flags.unsafe ? ' [allow-destructive: yes]' : '');

    const payloadObj = {
      model: flags.model,
      messages: [
        ...(sysPrompt ? [{ role: 'system', content: sysPrompt }] : []),
        { role: 'user', content: userPrompt },
      ],
      stream: false,
    };
    const payload = JSON.stringify(payloadObj);

    const data = await chatOnce({ payload });
    const text = (data && data.message && data.message.content) ? String(data.message.content) : '';
    const line = firstNonEmptyLine(text);
    const sanitized = sanitizeModelOutput(line);
    if (!sanitized) process.exit(2);

    // Enforce safety client-side as a backstop if model slips
    // Consider any explicit deletion or forceful termination as destructive unless --unsafe
    const destructivePatterns = new RegExp(
      [
        String.raw`\brm\b`,
        String.raw`\brmdir\b`,
        String.raw`find[\s\S]*?(-delete| -exec\s+rm\b)`,
        String.raw`mkfs\.`,
        String.raw`dd\s+of=`,
        String.raw`: \(\) \{ \s*:\|:\s*; \}\s*:\s*`,
        String.raw`chown\s+-R\s+\/\.`,
        String.raw`chmod\s+-R\s+0\s+\/\.`,
        String.raw`kill\s*-9\s*\d+`,
        String.raw`xargs\s+kill\s*-9`,
        String.raw`\bshutdown\b`,
        String.raw`\breboot\b`,
      ].join('|'),
      'i'
    );
    if (!flags.unsafe && destructivePatterns.test(sanitized)) {
      process.stdout.write('echo "# refused: destructive without --unsafe"');
      return;
    }

    if (flags.explain) {
      process.stdout.write(`# ${content}\n`);
    }
    process.stdout.write(sanitized);
  } catch (err) {
    process.exit(2);
  }
})();


