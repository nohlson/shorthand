#!/usr/bin/env node

// Local-only CLI that queries the Ollama server and prints exactly one zsh command.
// Flags:
//   --model=<name> (default: cmdgen)
//   --explain       (prints a one-line # comment before the command)
//   --unsafe        (permits destructive output)

const http = require('http');
const fs = require('fs');
const path = require('path');

function parseFlags(argv) {
  const flags = { model: 'cmdgen', explain: false, unsafe: false };
  const rest = [];
  for (const arg of argv) {
    if (arg.startsWith('--model=')) {
      flags.model = arg.slice('--model='.length);
    } else if (arg === '--explain') {
      flags.explain = true;
    } else if (arg === '--unsafe') {
      flags.unsafe = true;
    } else {
      rest.push(arg);
    }
  }
  return { flags, rest };
}

function promptFromArgsOrStdin(restArgs) {
  return new Promise((resolve) => {
    const arg = restArgs.join(' ').trim();
    if (arg) return resolve(arg);
    let buf = '';
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', (d) => (buf += d));
    process.stdin.on('end', () => resolve(buf.trim()))
    if (process.stdin.isTTY) {
      process.stderr.write('Prompt: ');
      process.stdin.resume();
    }
  });
}

function chatOnce({ host = '127.0.0.1', port = 11434, path = '/api/chat', payload }) {
  return new Promise((resolve, reject) => {
    const req = http.request(
      { host, port, path, method: 'POST', headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) } },
      (res) => {
        let out = '';
        res.setEncoding('utf8');
        res.on('data', (d) => (out += d));
        res.on('end', () => {
          try {
            const data = JSON.parse(out);
            resolve(data);
          } catch (e) {
            reject(new Error('invalid_json'));
          }
        });
      }
    );
    req.on('error', (err) => reject(err));
    req.write(payload);
    req.end();
  });
}

function firstNonEmptyLine(text) {
  return (text || '')
    .split('\n')
    .map((l) => l.trim())
    .find((l) => l.length > 0) || '';
}

function sanitizeModelOutput(line) {
  if (!line) return '';
  let s = String(line).trim();
  // Strip fenced code blocks if present
  if (s.startsWith('```')) {
    s = s.replace(/^```[a-zA-Z0-9_-]*\s*/, '');
    s = s.replace(/\s*```$/, '');
    s = firstNonEmptyLine(s);
  }
  // Remove wrapping single backticks and any stray backticks
  if (s.startsWith('`') && s.endsWith('`')) {
    s = s.slice(1, -1).trim();
  }
  s = s.replace(/`/g, '');
  // Drop common prompt prefixes
  s = s.replace(/^\s*(?:\$|❯|>|PS>|%)\s+/, '');
  return s.trim();
}

(function ensureStdioNoBlock() {
  // Best-effort to avoid hanging if parent process closes stdio
  try { process.stdin.setMaxListeners(0); } catch (_) {}
  try { process.stdout.setMaxListeners(0); } catch (_) {}
  try { process.stderr.setMaxListeners(0); } catch (_) {}
})();

const CONTEXT_START = '<<<CWD_CONTEXT_START_DO_NOT_COPY>>>';
const CONTEXT_END = '<<<CWD_CONTEXT_END_DO_NOT_COPY>>>';

function buildCwdContext() {
  try {
    const cwd = process.cwd();
    let entries = [];
    try {
      const dirents = fs.readdirSync(cwd, { withFileTypes: true });
      // Format: directories end with '/', files are plain names
      entries = dirents
        .map((d) => (d.name || ''))
        .filter((n) => n && n !== '.' && n !== '..')
        .map((name) => {
          let suffix = '';
          try {
            const st = fs.lstatSync(path.join(cwd, name));
            if (st.isDirectory()) suffix = '/';
          } catch (_) {}
          return name + suffix;
        })
        .sort((a, b) => a.localeCompare(b));
    } catch (_) {
      // ignore directory read errors; we will still send cwd
    }

    const MAX_ENTRIES = 200;
    const trimmed = entries.slice(0, MAX_ENTRIES);
    const more = entries.length > MAX_ENTRIES ? `\n# … ${entries.length - MAX_ENTRIES} more not shown` : '';

    const lines = [
      CONTEXT_START,
      '# Context for disambiguation; do not include any of these lines or tags in your output.',
      `cwd: ${cwd}`,
      'entries:',
      ...trimmed.map((e) => `- ${e}`),
      more && more,
      CONTEXT_END,
    ].filter(Boolean);

    return lines.join('\n');
  } catch (_) {
    return '';
  }
}

(async () => {
  try {
    const { flags, rest } = parseFlags(process.argv.slice(2));
    let content = await promptFromArgsOrStdin(rest);
    if (!content) process.exit(1);

    const sysPrompt = undefined; // System prompt lives in the Modelfile
    const contentHasUnsafe = /(?<=^|\s)--unsafe(?=$|\s)/.test(content);
    if (contentHasUnsafe) {
      flags.unsafe = true;
    }
    const userPrompt = content + (flags.unsafe && !contentHasUnsafe ? ' --unsafe' : '');
    const contextBlock = buildCwdContext();

    const payloadObj = {
      model: flags.model,
      messages: [
        ...(sysPrompt ? [{ role: 'system', content: sysPrompt }] : []),
        { role: 'user', content: userPrompt },
        ...(contextBlock ? [{ role: 'user', content: `The following lines are context to help interpret file and directory names. Do not copy any of it.\n${contextBlock}` }] : []),
      ],
      stream: false,
    };
    const payload = JSON.stringify(payloadObj);

    const data = await chatOnce({ payload });
    const text = (data && data.message && data.message.content) ? String(data.message.content) : '';
    const line = firstNonEmptyLine(text);
    let sanitized = sanitizeModelOutput(line);
    // Extra safety: strip any leaked context tags if the model echoed them
    const leakTags = [CONTEXT_START, CONTEXT_END, '--8<-- CWD CONTEXT START', '--8<-- CWD CONTEXT END'];
    for (const tag of leakTags) {
      const idx = sanitized.indexOf(tag);
      if (idx !== -1) {
        sanitized = sanitized.slice(0, idx).trim();
      }
    }
    if (!sanitized) process.exit(2);

    // Enforce safety client-side as a backstop if model slips
    // Consider any explicit deletion or forceful termination as destructive unless --unsafe
    const destructivePatterns = new RegExp(
      [
        String.raw`\brm\b`,
        String.raw`\brmdir\b`,
        String.raw`find[\s\S]*?(-delete| -exec\s+rm\b)`,
        String.raw`mkfs\.`,
        String.raw`dd\s+of=`,
        String.raw`: \(\) \{ \s*:\|:\s*; \}\s*:\s*`,
        String.raw`chown\s+-R\s+\/\.`,
        String.raw`chmod\s+-R\s+0\s+\/\.`,
        String.raw`kill\s*-9\s*\d+`,
        String.raw`xargs\s+kill\s*-9`,
        String.raw`\bshutdown\b`,
        String.raw`\breboot\b`,
      ].join('|'),
      'i'
    );
    if (!flags.unsafe && destructivePatterns.test(sanitized)) {
      process.stdout.write('echo "# refused: destructive without --unsafe"');
      return;
    }

    if (flags.explain) {
      process.stdout.write(`# ${content}\n`);
    }
    process.stdout.write(sanitized);
  } catch (err) {
    process.exit(2);
  }
})();


